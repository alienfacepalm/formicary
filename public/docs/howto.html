<h2 id="how-to-guides">How-to Guides</h2>
<h3 id="scheduling">Scheduling</h3>
<p>Once a job configuration is defined and uploaded, you can submit a new job manually as follows:</p>
<pre><code class="lang-yaml">curl -v -H &quot;Authorization:
  Bearer $TOKEN&quot; -H &quot;Content-Type:
    application/json&quot; --data &#39;{&quot;job_type&quot;: &quot;hello_world&quot;, &quot;params&quot;: { &quot;Target&quot;: &quot;bob&quot; } }&#39; $SERVER/api/jobs/requests
</code></pre>
<p>The above example will kick off <code>hello_world</code> immediately based on available resources.</p>
<h3 id="scheduling_future">Scheduling_Future</h3>
<p>You can submit a job at scheduled time by adding <code>scheduled_at</code> parameter as follows:</p>
<pre><code class="lang-yaml">curl -v -H &quot;Authorization:
  Bearer $TOKEN&quot; -H &quot;Content-Type:
    application/json&quot; --data &#39;{&quot;job_type&quot;: &quot;hello_world&quot;, &quot;scheduled_at&quot;: &quot;2025-06-15T00:00:00.0-00:00&quot;, &quot;params&quot;: { &quot;Target&quot;: &quot;bob&quot; } }&#39; $SERVER/api/jobs/requests
</code></pre>
<p>The above example will kick off <code>hello_world</code> job based on <code>scheduled_at</code> time in the future, however the job will be immediately scheduled if the <code>scheduled_at</code> is in the past.</p>
<h3 id="cron">Cron</h3>
<p>See <a href="definition_options.html#cron_trigger">Job Filtering</a> for scheduling job at a regular interval using cron syntax.</p>
<h3 id="job-filtering">Job-Filtering</h3>
<p>See <a href="definition_options.html#filter">Job Filtering</a> for filtering scheduled job.</p>
<h3 id="configs">Configs</h3>
<p>In addition to specifying variables in the job-configuration and pass as request parameters, you can store common or sensitive configuration separately, which can be references within the job definition. These configurations can be updated using dashboard UI or API, e.g., following example stores organization specific configurations:</p>
<pre><code class="lang-bash">curl -v -H &quot;Authorization: Bearer $TOKEN&quot; -H &quot;Content-Type: application/yaml&quot; \
  $SERVER/api/orgs/&lt;org-id&gt;/configs -d &#39;{&quot;Name&quot;: &quot;MyToken&quot;, &quot;Value&quot;: &quot;TokenValue&quot;}&#39;
</code></pre>
<p>Similarly, following example adds configuration for a specific job:</p>
<pre><code class="lang-bash">curl -v -H &quot;Authorization: Bearer $TOKEN&quot; -H &quot;Content-Type: application/yaml&quot; \
  $SERVER/api/jobs/definitions/&lt;job-id&gt;/configs -d &#39;{&quot;Name&quot;: &quot;MyToken&quot;, &quot;Value&quot;: &quot;TokenValue&quot;}&#39;
</code></pre>
<h3 id="caching">Caching</h3>
<p>Formicary also provides caching for directories that store 3rd party dependencies, e.g., following example shows how all node_modules will be cached:</p>
<pre><code class="lang-yaml">   cache:
     key_paths:
       - go.mod
     paths:
       - vendor
</code></pre>
<p>In above example <code>vendor</code> folder will be cached between the runs of the job and the cache key will be based on contents of <code>go.mod</code>.</p>
<p>You can also specify a <code>key</code> instead of file based <code>key_paths</code>, e.g.</p>
<pre><code class="lang-yaml">   cache:
     key: {{.CommitID}}
     paths:
       - vendor
</code></pre>
<p>This key allows sharing cache between tasks, e.g., <code>release</code> tag is reusing this cache with the same key:</p>
<pre><code class="lang-yaml">- task_type: release
  method: KUBERNETES
  script:
    - ls -al .cache/pip venv
  cache:
    key: cache-key
    paths:
      - .cache/pip
      - venv
</code></pre>
<h3 id="repositories_access_tokens">Repositories_Access_Tokens</h3>
<p>The formicary supports encrypted storage for tokens and password that can be used to access the source code repositories. For example, if you are using GitHub you can create <a href="https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token">personal access token</a> and then checkout code, e.g.,</p>
<pre><code class="lang-bash">git clone https://&lt;your-token&gt;@github.com/&lt;yourid&gt;/&lt;your-project&gt;.git
</code></pre>
<p>Alternatively, you can use username/password such as:</p>
<pre><code class="lang-bash">git clone https://&lt;username&gt;:&lt;password&gt;@github.com/&lt;yourid&gt;/&lt;your-project&gt;.git
</code></pre>
<p>Or you can store ssh keys in job-definition / organization configs for accessing the git repositories:</p>
<pre><code class="lang-bash">git clone https://&lt;username&gt;:&lt;password&gt;@github.com/&lt;yourid&gt;/&lt;your-project&gt;.git
</code></pre>
<h3 id="webhooks">Webhooks</h3>
<p>You can submit jobs by creating GitHub Webhook, e.g., <img src="github_webhook.png" alt="Github Webhook"></p>
<p>First set <code>Payload URL</code> to <code>$SERVER/auth/github/webhook?authorization=&lt;api-token&amp;job=&lt;job-type&gt;</code>, where the <code>api-token</code> can be generated from the dashboard-UI and <code>job</code> points to the job-type that you have configured. Next, set a secret for the payload and add a job configuration for <code>GithubWebhookSecret</code>, e.g.</p>
<pre><code class="lang-bash">curl -v -H &quot;Authorization: Bearer $TOKEN&quot; \
  -H &quot;Content-Type: application/yaml&quot; \
  $SERVER/api/jobs/definitions/&lt;job-type&gt;/configs -d &#39;{&quot;Name&quot;: &quot;GithubWebhookSecret&quot;, &quot;Value&quot;: &quot;my-secret&quot;, &quot;Secret&quot;: true}&#39;
</code></pre>
<p>Anytime, when someone checks in a code, the webhook will trigger the job to execute, and the job receives following parameters:</p>
<ul>
<li>GitBranch</li>
<li>GitCommitAuthor</li>
<li>GitCommitID</li>
<li>GitCommitMessage</li>
<li>GitRepository</li>
<li>GithubRepositoryURL</li>
</ul>
<p>Above parameters can be used to check out the branch or commit and then execute CI/CD, e.g.</p>
<pre><code class="lang-yaml">- task_type: build
  host_network: true
  method: KUBERNETES
  working_dir: /sample
  container:
    image: node:16-buster
  before_script:
    - git clone https://{{.GithubToken}}@github.com/bhatti/node-crud.git .
    - git checkout -t origin/{{.GitBranch}} || git checkout {{.GitBranch}}
  script:
    - echo branch {{.GitBranch}}, Commit {{.GitCommitID}}
    - npm install
</code></pre>
<h3 id="postcommit">PostCommit</h3>
<p>You can also submit jobs by creating Git post-commit hooks by creating a <code>post-commit</code> file under <code>.git/hooks</code> such as:</p>
<pre><code class="lang-bash">#!/bin/sh
export SHORT_COMMIT=`git describe --always --long --dirty`
export COMMIT=`git rev-parse --verify HEAD`
export BRANCH=`git rev-parse --symbolic-full-name --abbrev-ref HEAD`
export AUTHOR=`git log -1 --pretty=format:&#39;%an&#39;`
export AUTHOR_EMAIL=`git log -1 --pretty=format:&#39;%ae&#39;`
export COMMIT_MESSAGE=`git log -1 --pretty=%B`

curl -v -H &quot;Authorization: Bearer $FRM_TOKEN&quot; \
  -H &quot;Content-Type: application/yaml&quot; \
    --data-binary @node_build.yaml $FRM_SERVER/api/jobs/definitions || echo &#39;failed to upload ci job configuration for node_build&#39;
curl -v -H &quot;Authorization: Bearer $FRM_TOKEN&quot; \
  -H &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;job_type\&quot;: \&quot;node_build\&quot;, \&quot;params\&quot;: {\&quot;GitCommitID\&quot;: \&quot;$COMMIT\&quot;, \&quot;GitBranch\&quot;: \&quot;$BRANCH\&quot;, \&quot;GitCommitMessage\&quot;: \&quot;$COMMIT_MESSAGE\&quot;}}&quot; $FRM_SERVER/api/jobs/requests || echo &#39;failed to submit ci job configuration for node_build&#39;
</code></pre>
<p>You can store the job configuration in your home folder and then use above script to submit the job request. Above script assumes the <code>$FRM_SERVER</code> points to formicary-server and <code>$FRM_TOKEN</code> points to the API token, it then uploads the job configuration and then submits the job passing the commit and branch as parameters. You can then refer to those parameters from the job configuration, e.g.</p>
<pre><code class="lang-yaml">- task_type: build
  host_network: true
  method: KUBERNETES
  working_dir: /sample
  container:
    image: node:16-buster
  before_script:
    - git clone https://{{.GithubToken}}@github.com/bhatti/node-crud.git .
    - git checkout -t origin/{{.GitBranch}} || git checkout {{.GitBranch}}
  script:
    - echo branch {{.GitBranch}}, Commit {{.GitCommitID}}
    - npm install
  after_script:
    - ls -l
</code></pre>
<p>Anytime, when someone checks in a code, the webhook will trigger the job for execution, and the job will receive following parameters:</p>
<ul>
<li>GitBranch</li>
<li>GitCommit</li>
</ul>
<h3 id="docker-in-docker-dind-">Docker in Docker (dind)</h3>
<p>See <a href="dind.html">Building Docker images</a> for building images using docker in docker.</p>
<h3 id="scanning-go-source-https-github-com-securego-gosec-">Scanning GO source (<a href="https://github.com/securego/gosec">https://github.com/securego/gosec</a>)</h3>
<p>See <a href="gosec-scan.html">Scanning Golang using gosec</a> for scanning GO source code.</p>
<h3 id="scanning-containers-for-security">Scanning containers for security</h3>
<p>See <a href="trivy-scan.html">Scanning containers using Trivy</a> for scanning containers for security.</p>
<h3 id="advanced-kubernetes">Advanced Kubernetes</h3>
<p>See <a href="advanced_k8.html">Advanced Kubernetes</a> for using advanced kubernetes configs.</p>
